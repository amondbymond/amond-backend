name: Deploy Backend to EC2

on:
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Deploy via SSM
        id: deploy
        run: |
          # Create .env content
          ENV_CONTENT=$(cat <<'EOL'
          NODE_ENV=${{ secrets.NODE_ENV }}
          DB_HOST=${{ secrets.DB_HOST }}
          DB_DATABASE=${{ secrets.DB_DATABASE }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          SESSION_SECRET=${{ secrets.SESSION_SECRET }}
          CRYPTO_KEY=${{ secrets.CRYPTO_KEY }}
          CRYPTO_DELETED_KEY=${{ secrets.CRYPTO_DELETED_KEY }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          AWS_ACCESS_KEY=${{ secrets.AWS_ACCESS_KEY }}
          AWS_SECRET_ACCESS=${{ secrets.AWS_SECRET_ACCESS }}
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REFRESH_TOKEN=${{ secrets.GOOGLE_REFRESH_TOKEN }}
          KAKAO_REST_API=${{ secrets.KAKAO_REST_API }}
          YOUTUBE_API_KEY=${{ secrets.YOUTUBE_API_KEY }}
          CHROME_BIN=/usr/local/bin/chromium
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          INICIS_PROD_MID=${{ secrets.INICIS_PROD_MID }}
          INICIS_PROD_SIGN_KEY=${{ secrets.INICIS_PROD_SIGN_KEY }}
          INICIS_PROD_API_KEY=${{ secrets.INICIS_PROD_API_KEY }}
          INICIS_PROD_API_IV=${{ secrets.INICIS_PROD_API_IV }}
          BILLING_CRON_SCHEDULE=${{ secrets.BILLING_CRON_SCHEDULE }}
          EOL
          )
          
          # Base64 encode the .env content to safely pass it through SSM
          ENV_BASE64=$(echo "$ENV_CONTENT" | base64 -w 0)
          
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "{\"commands\":[
              \"echo '=== Starting deployment ==='\",
              \"# Set up PATH for nvm/node/npm\",
              \"export NVM_DIR='/home/ec2-user/.nvm'\",
              \"[ -s \\\"\\$NVM_DIR/nvm.sh\\\" ] && . \\\"\\$NVM_DIR/nvm.sh\\\"\",
              \"export PATH=\\$PATH:/home/ec2-user/.nvm/versions/node/v18.*/bin\",
              \"# Fix git ownership issue\",
              \"git config --global --add safe.directory /home/${{ secrets.EC2_USER }}/${{ secrets.EC2_FOLDER_NAME }}/backend\",
              \"cd /home/${{ secrets.EC2_USER }}/${{ secrets.EC2_FOLDER_NAME }}/backend || exit 1\",
              \"echo '=== Pulling latest code from GitHub ==='\",
              \"git fetch origin main\",
              \"git reset --hard origin/main\",
              \"echo '=== Creating .env file ==='\",
              \"echo '$ENV_BASE64' | base64 -d > .env\",
              \"echo '=== Installing dependencies ==='\",
              \"npm install --production\",
              \"echo '=== Building TypeScript (if needed) ==='\",
              \"if [ -f tsconfig.json ]; then npm run build || echo 'No build script found'; fi\",
              \"echo '=== Restarting application ==='\",
              \"pm2 restart ${{ secrets.PM2_PROCESS_NAME }} || pm2 start app.ts --name ${{ secrets.PM2_PROCESS_NAME }}\",
              \"pm2 save\",
              \"echo '=== Deployment complete ==='\",
              \"pm2 status\"
            ]}" \
            --timeout-seconds 600 \
            --output text \
            --query 'Command.CommandId')
          
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      - name: Wait for deployment
        run: |
          COMMAND_ID="${{ steps.deploy.outputs.command_id }}"
          echo "Waiting for deployment command $COMMAND_ID to complete..."
          
          # Wait for command to complete
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")
            
            echo "Status: $STATUS"
            
            if [ "$STATUS" == "Success" ]; then
              echo "‚úÖ Deployment completed successfully!"
              break
            elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
              echo "‚ùå Deployment failed with status: $STATUS"
              
              # Get error logs
              echo "Error output:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query 'StandardErrorContent' \
                --output text
              
              exit 1
            fi
            
            sleep 10
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå Deployment timed out waiting for completion"
            exit 1
          fi

      - name: Get deployment logs
        if: always()
        run: |
          if [ -n "${{ steps.deploy.outputs.command_id }}" ]; then
            echo "üìã Deployment output:"
            aws ssm get-command-invocation \
              --command-id "${{ steps.deploy.outputs.command_id }}" \
              --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
              --query 'StandardOutputContent' \
              --output text || echo "Could not retrieve output"
          fi